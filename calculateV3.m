(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
(*  Calculation[m, n, \[Omega]mT, HFImT, dc, k, Abort]

m must be even, dc=1/(6\[Tau]_c) where \[Tau]_c is time to rotate by 1 radian,
 Abort=True runs everything but the integral dt, for debugging (e.g. evaluating \[Sigma](t) at a given time);

HFImT is a list of tuples of the form {"X",a,\[CapitalDelta]A}: X=A or X=B, a = isotropic HFI strength/mT, \[CapitalDelta]A = axial HFI strength/mT;

Example use: Calculation[6,6,0,{{"A",1.2,0.7},{"A",1,0},{"B",1.7,1.2}},0,10^6];

can change dt or tmax in Calcuations[] to adjust the balance between accuracy and speed in numerical integration;

calculation time scales as (2^((Na+Nb)*m*n))^2/k;

eq X.XX refers to J. Lau's part II thesis;*)


(* ::Input::Initialization:: *)
A[n_,i_,j_]:=n(i-1)+j; (*DiffusionMatrix[] left exactly as in Peter's work*)
DiffusionMatrix[m_,n_,\[Chi]_,Potential_]:=(
mn=m*n;  da=(2.0 \[Pi])/m; dq=2.0/n;q[j_]:=-1.0+(j-0.5)dq; W=SparseArray[{},{mn,mn}];
Do[f=1/(da^2*(1-q[j]^2));
W[[A[n,i,j],A[n,i+1,j]]]=W[[A[n,i,j],A[n,i+1,j]]]+f;
 W[[A[n,i,j],A[n,i,j]]]=W[[A[n,i,j],A[n,i,j]]]-2.0*f;
 W[[A[n,i,j],A[n,i-1,j]]]=W[[A[n,i,j],A[n,i-1,j]]]+f,
 {j,1,n},{i,2,m-1}];
Do[f=1/(da^2*(1-q[j]^2));W[[A[n,m,j],A[n,1,j]]]=W[[A[n,m,j],A[n,1,j]]]+f;W[[A[n,m,j],A[n,m,j]]]=W[[A[n,m,j],A[n,m,j]]]-2.0*f;W[[A[n,m,j],A[n,m-1,j]]]=W[[A[n,m,j],A[n,m-1,j]]]+f,
 {j,1,n}];

Do[f=1/(da^2*(1-q[j]^2));W[[A[n,1,j],A[n,2,j]]]=W[[A[n,1,j],A[n,2,j]]]+f;W[[A[n,1,j],A[n,1,j]]]=W[[A[n,1,j],A[n,1,j]]]-2.0*f;W[[A[n,1,j],A[n,m,j]]]=W[[A[n,1,j],A[n,m,j]]]+f,
 {j,1,n}];

Do[f=(1.0-q[j]^2)/dq^2;W[[A[n,i,j],A[n,i,j+1]]]=W[[A[n,i,j],A[n,i,j+1]]]+f;W[[A[n,i,j],A[n,i,j]]]=W[[A[n,i,j],A[n,i,j]]]-2.0*f;W[[A[n,i,j],A[n,i,j-1]]]=W[[A[n,i,j],A[n,i,j-1]]]+f,
 {j,2,n-1},{i,1,m}];

Do[f=(1.0-q[n]^2)/dq^2;If[i<=m/2,ip=i+m/2,ip=i-m/2];W[[A[n,i,n],A[n,ip,n]]]=W[[A[n,i,n],A[n,ip,n]]]+f;W[[A[n,i,n],A[n,i,n]]]=W[[A[n,i,n],A[n,i,n]]]-2.0*f;W[[A[n,i,n],A[n,i,n-1]]]=W[[A[n,i,n],A[n,i,n-1]]]+f,
{i,1,m}];

Do[f=(1.0-q[1]^2)/dq^2;If[i<=m/2,ip=i+m/2,ip=i-m/2];W[[A[n,i,1],A[n,i,2]]]=W[[A[n,i,1],A[n,i,2]]]+f;W[[A[n,i,1],A[n,i,1]]]=W[[A[n,i,1],A[n,i,1]]]-2.0*f;W[[A[n,i,1],A[n,ip,1]]]=W[[A[n,i,1],A[n,ip,1]]]+f,
{i,1,m}];

Do[f=q[j]/dq;W[[A[n,i,j],A[n,i,j+1]]]=W[[A[n,i,j],A[n,i,j+1]]]-f;
W[[A[n,i,j],A[n,i,j-1]]]=W[[A[n,i,j],A[n,i,j-1]]]+f,
 {j,2,n-1},{i,1,m}];

Do[f=q[n]/dq;If[i<=m/2,ip=i+m/2,ip=i-m/2];W[[A[n,i,n],A[n,ip,n]]]=W[[A[n,i,n],A[n,ip,n]]]-f;W[[A[n,i,n],A[n,i,n-1]]]=W[[A[n,i,n],A[n,i,n-1]]]+f,
{i,1,m}];

Do[f=q[1]/dq;If[i<=m/2,ip=i+m/2,ip=i-m/2];W[[A[n,i,1],A[n,i,2]]]=W[[A[n,i,1],A[n,i,2]]]-f;W[[A[n,i,1],A[n,ip,1]]]=W[[A[n,i,1],A[n,ip,1]]]+f,
 {i,1,m}];

Do[f=\[Chi] If[Potential==1,(q[j]*(1.0-q[j]^2))/(2.0*dq),(Sqrt[1.0-q[j]^2]*ArcCos[q[j]])/(2.0*dq)];W[[A[n,i,j],A[n,i,j+1]]]=W[[A[n,i,j],A[n,i,j+1]]]-f;W[[A[n,i,j],A[n,i,j-1]]]=W[[A[n,i,j],A[n,i,j-1]]]+f,
 {j,2,n-1},{i,1,m}];

Do[f=\[Chi] If[Potential==1,(q[n]*(1.0-q[n]^2))/(2.0*dq),(Sqrt[1.0-q[n]^2]*ArcCos[q[n]])/(2.0*dq)];If[i<=m/2,ip=i+m/2,ip=i-m/2];W[[A[n,i,n],A[n,ip,n]]]=W[[A[n,i,n],A[n,ip,n]]]-f;W[[A[n,i,n],A[n,i,n-1]]]=W[[A[n,i,n],A[n,i,n-1]]]+f,
{i,1,m}];

Do[f=\[Chi] If[Potential==1,(q[1]*(1.0-q[1]^2))/(2.0*dq),(Sqrt[1.0-q[1]^2]*ArcCos[q[1]])/(2.0*dq)];If[i<=m/2,ip=i+m/2,ip=i-m/2];W[[A[n,i,1],A[n,i,2]]]=W[[A[n,i,1],A[n,i,2]]]-f;W[[A[n,i,1],A[n,ip,1]]]=W[[A[n,i,1],A[n,ip,1]]]+f,
 {i,1,m}];

Do[f=\[Chi] If[Potential==1, (3.0*q[j]^2-1.0),((q[j]*ArcCos[q[j]])/Sqrt[1-q[j]^2]+1.0)];
W[[A[n,i,j],A[n,i,j]]]=W[[A[n,i,j],A[n,i,j]]]+f,
 {j,1,n},{i,1,m}];

(* Do[f=4.0*\[Chi]/n^2;W[[A[n,i,j],A[n,i,j]]]=W[[A[n,i,j],A[n,i,j]]]+f, {j,2,n-1},{i,1,m}];

Do[f=\[Chi](3.0 n-8.0)/(2.0 n^2);W[[A[n,i,j],A[n,i,j]]]=W[[A[n,i,j],A[n,i,j]]]-f,{j,1,n,n-1},{i,1,m}]; *)

ColumnSum=Table[Total[W[[All,b]]],{b,1,mn}];
Do[f=ColumnSum[[A[n,i,j]]];W[[A[n,i,j],A[n,i,j]]]=W[[A[n,i,j],A[n,i,j]]]-f, {j,1,n},{i,1,m}];
ColumnSum=Table[Total[W[[All,b]]],{b,1,mn}] //Chop );



Id=({
 {1, 0},
 {0, 1}
});     Subscript[\[Sigma], x]=({
 {0, 1/2},
 {1/2, 0}
});     Subscript[\[Sigma], y]=({
 {0, -I/2},
 {I/2, 0}
});     Subscript[\[Sigma], z]=({
 {1/2, 0},
 {0, -1/2}
});
\[Sigma]p=Subscript[\[Sigma], x]+I Subscript[\[Sigma], y]; \[Sigma]m=Subscript[\[Sigma], x]-I Subscript[\[Sigma], y];
Kron:=KroneckerProduct;
Kron2[{args__}]:=KroneckerProduct[args]; (*IMPORTANT: Kron2[] is same as KroneckerProduct[] but takes a single argument only: a list {M1,M2,M3,...} of matrices M*)
mT2angfreq=1.76 10^8;
Spins={Id/Sqrt[2.0],Sqrt[2.0] Subscript[\[Sigma], z],\[Sigma]p,\[Sigma]m};
 SA[p_]:=Kron[Spins[[p]],IdentityMatrix[2^Na]]/Sqrt[2.0] //Flatten; SAdag[p_]:=Kron[Spins[[p]],IdentityMatrix[2^Na]]\[ConjugateTranspose]/Sqrt[2.0] //Flatten;  (*SAdag has Hermitian conjugate...*)
SB[p_]:=Kron[Spins[[p]],IdentityMatrix[2^Nb]]/Sqrt[2.0] //Flatten; SBdag[p_]:=Kron[Spins[[p]],IdentityMatrix[2^Nb]]\[ConjugateTranspose]/Sqrt[2.0] //Flatten; (*...before flattening*)
M=2^(Na+Nb);(* # nuclear spin states; Na & Nb are assigned in Calculation[]*)


Hamiltonian[\[Omega]_,HFI_,m_,n_,i_,j_]:=(
dq=2.0/n; da=(2.0 \[Pi])/m; q[jj_]:=-1.0+(jj-0.5)dq; \[Alpha][ii_]:=(ii-1.0)da; WigD=Table[0,{5}];
WigD[[1]]=1/2 Sqrt[3/2](1-q[j]^2)Exp[I 2.0 \[Alpha][i]];
WigD[[2]]=Sqrt[3/2]q[j]Sqrt[1-q[j]^2] Exp[I \[Alpha][i]];
WigD[[3]]=1/2 (3q[j]^2-1);
WigD[[4]]=-Sqrt[(3/2)]q[j]Sqrt[1-q[j]^2] Exp[-I \[Alpha][i]];
WigD[[5]]=1/2 Sqrt[3/2](1-q[j]^2)Exp[-I 2.0 \[Alpha][i]];

IA=IdentityMatrix[2^(1+Na)]; (*Identity operator for entire radical A*)
IB=IdentityMatrix[2^(1+Nb)];

(*** Extract constants from fct argument ***)
Ahfc =Pick[HFI[[All]],StringStartsQ[HFI[[All,1]],"A"]];ihfca= Ahfc[[All,2]];\[CapitalDelta]Aa=Ahfc[[All,3]]; (*Pick[] does what it says on the tin*)
Bhfc=Pick[HFI[[All]],StringStartsQ[HFI[[All,1]],"B"]];ihfcb=Bhfc[[All,2]];\[CapitalDelta]Ab=Bhfc[[All,3]];

If[Na==0,ihfca=0; =0];If[Nb==0,ihfcb=0;\[CapitalDelta]Ab=0]; (*for N=0 sets our constants to 0 instead of having them as empty arrays {}*)

(***Zeeman***)
HA=\[Omega](Kron[Subscript[\[Sigma], z],IdentityMatrix[2^Na]]); (*unconstrained radical so can set B-field to be at \[Theta]=0 w.l.g.*)
HB=\[Omega](Kron[Subscript[\[Sigma], z],IdentityMatrix[2^Nb]]); 

(***Isotropic HFIs***)
NAId = If[Na>1,ConstantArray[Id,Na-1],{{1}}];(*Identity operator for N-1 nuclei only*)
NBId = If[Nb>1,ConstantArray[Id,Nb-1],{{1}}];

Pax=Permutations[Join[NAId, {Subscript[\[Sigma], x]}]];Pay=Permutations[Join[NAId, {Subscript[\[Sigma], y]}]];Paz=Permutations[Join[NAId, {Subscript[\[Sigma], z]}]]; (*See large commented sect below*)
Pbx=Permutations[Join[NBId, {Subscript[\[Sigma], x]}]];Pby=Permutations[Join[NBId , {Subscript[\[Sigma], y]}]];Pbz=Permutations[Join[NBId , {Subscript[\[Sigma], z]}]];

HA=HA+Sum[ihfca[[j]] (Kron2[Join[{Subscript[\[Sigma], x]},Pax[[j]]]] (*isotropic HFI terms for each nucleus e.g. Subscript[\[Sigma], z]\[CircleTimes]Id\[CircleTimes]Subscript[\[Sigma], z] & Subscript[\[Sigma], z]\[CircleTimes]Subscript[\[Sigma], z]\[CircleTimes]Id and so on for more spins*)
				+Kron2[Join[{Subscript[\[Sigma], y]},Pay[[j]]]]
				+Kron2[Join[{Subscript[\[Sigma], z]},Paz[[j]]]])

		,{j,1,Na}] ;

HB=HB+Sum[ihfcb[[j]] (Kron2[Join[{Subscript[\[Sigma], x]},Pbx[[j]]]] 
				+Kron2[Join[{Subscript[\[Sigma], y]},Pby[[j]]]]
				+Kron2[Join[{Subscript[\[Sigma], z]},Pbz[[j]]]])

		,{j,1,Nb}] ;

(***Anisotropic HFIs***)
Ta=ConstantArray[0,{Na,5}];(*each row is the same as the T from original code/Lau 2009 paper, but for a given nucleus' HFI*)
Tb=ConstantArray[0,{Nb,5}];

Pam=Permutations[Join[NAId, {\[Sigma]m}]];Pap=Permutations[Join[NAId, {\[Sigma]p}]]; 
Pbm=Permutations[Join[NBId, {\[Sigma]m}]];Pbp=Permutations[Join[NBId, {\[Sigma]p}]];
(******************************)
(*The formulas for T below are identical to the original code but with Identity operators inserted for any extra nuclei.

E.g. if A has 2 nuclear spins, then the code below ensures that we have T's corresponding to both of these hyperfine interactions. 
So Ta[[1,1]] (j=1) contains the \[Sigma]m \[CircleTimes] Id \[CircleTimes] \[Sigma]m term, while Ta[[2,1]] (j=2)  has \[Sigma]m \[CircleTimes] \[Sigma]m \[CircleTimes] Id.

The Pax/Pay/Paz/Pam/Pap arrays simply contain the different lists of operators we need,
so Paz contains for e.g. Na=4: {Subscript[\[Sigma], z] Id Id Id}, {Id Subscript[\[Sigma], z] Id Id}, {Id Id Subscript[\[Sigma], z] Id}, {Id Id Id Subscript[\[Sigma], z]}.  *)
(******************************)

Table[Ta[[j,1]]=1/2 Kron2[Join[{\[Sigma]m},Pam[[j]]]]; 
Ta[[j,2]]=  1/2 (Kron2[Join[{Subscript[\[Sigma], z]},Pam[[j]]]]+Kron2[Join[{\[Sigma]m},Paz[[j]]]]);
Ta[[j,3]]=Sqrt[2/3](Kron2[Join[{Subscript[\[Sigma], z]},Paz[[j]]]]-1/4 (Kron2[Join[{\[Sigma]p},Pam[[j]]]]+Kron2[Join[{\[Sigma]m},Pap[[j]]]])); 
Ta[[j,4]]=-(1/2)(Kron2[Join[{Subscript[\[Sigma], z]},Pap[[j]]]]+Kron2[Join[{\[Sigma]p},Paz[[j]]]]);

Ta[[j,5]]=1/2 Kron2[Join[{\[Sigma]p},Pap[[j]]]],
{j,1,Na}]//Chop;

Table[Tb[[j,1]]=1/2 Kron2[Join[{\[Sigma]m},Pbm[[j]]]]; 
Tb[[j,2]]=  1/2 (Kron2[Join[{Subscript[\[Sigma], z]},Pbm[[j]]]]+Kron2[Join[{\[Sigma]m},Pbz[[j]]]]);
Tb[[j,3]]=Sqrt[2/3](Kron2[Join[{Subscript[\[Sigma], z]},Pbz[[j]]]]-1/4 (Kron2[Join[{\[Sigma]p},Pbm[[j]]]]+Kron2[Join[{\[Sigma]m},Pbp[[j]]]])); 
Tb[[j,4]]=-(1/2)(Kron2[Join[{Subscript[\[Sigma], z]},Pbp[[j]]]]+Kron2[Join[{\[Sigma]p},Pbz[[j]]]]);

Tb[[j,5]]=1/2 Kron2[Join[{\[Sigma]p},Pbp[[j]]]],
{j,1,Nb}]//Chop;


HA=HA+Sum[ 
		(\[CapitalDelta]Aa[[iter]]/Sqrt[6])Sum[
					WigD[[mm]] Ta[[iter,mm]],

					{mm,1,5}]//N//Simplify,
		{iter,1,Na}]; 

HB=HB+Sum[ 
		(\[CapitalDelta]Ab[[iter]]/Sqrt[6])Sum[
					WigD[[mm]] Tb[[iter,mm]],

					{mm,1,5}]//N//Simplify,
		{iter,1,Nb}];

HAliouville=Kron[HA,IA]-Kron[IA,Transpose[HA]] ; 
HBliouville = Kron[HB,IB]-Kron[IB,Transpose[HB]] ; );

Clear[m,n,\[Omega],ahfc,\[CapitalDelta]A,\[Theta],\[Chi],dc,k,t]

Calculation[m_,n_,\[Omega]mT_,HFImT_,dc_,k_,abort_]:=(
HFI=HFImT;
{\[Omega],HFI[[All,{2,3}]]}={\[Omega]mT,HFImT[[All,{2,3}]]}*mT2angfreq;(*\[Theta]=\[Theta]deg\[Times]\[Pi]/180.0;*)
mn=m*n; 

Aconsts =Pick[HFI[[All]],StringStartsQ[HFI[[All,1]],"A"]];Na =Length[Aconsts[[All,1]]]; (*no. of nuclei is determined from input*)
Bconsts =Pick[HFI[[All]],StringStartsQ[HFI[[All,1]],"B"]];Nb =Length[Bconsts[[All,1]]];

DiffusionMatrix[m,n,0,1]; (*no potential \[Rule] \[Chi]=0*)
Hamiltonian[\[Omega],HFI,m,n,i,j];

p0=ConstantArray[1/mn,mn]; (*Initial distribution of orientations is simply uniform*)

(********************************)
p0=p0*Sqrt[mn]; (*BRUH MOMENT to make singlet probability 1 at t=0*)
(********************************)

p0SA=Table[Kron[p0,SA[j]]//Flatten,{j,1,4}];p0SAdag=Table[Kron[p0,SAdag[j]]//Flatten,{j,1,4}];
p0SB=Table[Kron[p0,SB[j]]//Flatten,{j,1,4}];p0SBdag=Table[Kron[p0,SBdag[j]]//Flatten,{j,1,4}];

IdHA=SparseArray[{a_,a_}->1,Dimensions[HAliouville]];IdHB=SparseArray[{a_,a_}->1,Dimensions[HBliouville]];

ijvals=Tuples[{Range[m],Range[n]}]; (*spits out {1,1} {1,2} ... {1,n} {2,1} {2,2} ... {2,n} ...{m,n}*)

 (*eq 4.8*)
HHA=Sum[
		Kron[
			SparseArray[{a,a}->1,{mn,mn}],
			HAliouville/.Thread[{i,j}->ijvals[[a]] ] (*Thread[] lets you sub in an array / a pair of elements instead of individually doing 'em*)
			 ],
		{a,1,mn}
		]; 

HHB=Sum[
		Kron[
			SparseArray[{a,a}->1,{mn,mn}],
			HBliouville/.Thread[{i,j}->ijvals[[a]] ] 
			],
		{a,1,mn}
		];

(*eqs 4.34, 4.05 *)
LA:= I HHA-dc Kron[W,IdHA]; 
LB:= I HHB-dc Kron[W,IdHB];

dt =10^(-9);
h =dt/2 ;
tmax = 5/k;(*t>5/k negligible*)
hnum=999*10^6/k;(* hnum+1 is total number of points, due to the point at t=0*)

\[Sigma]vals=ConstantArray[0,hnum+1];
RAq=Table[p0SA[[q]],{q,2,4}] ;(*initialise at t=0*)
RBq=Table[p0SBdag[[q]],{q,2,4}];
p0SAp=Table[p0SAdag[[p]],{p,2,4}]; (*And collect LH p-indexed terms in a vector*)
p0SBp=Table[p0SB[[p]],{p,2,4}];

\[Sigma]vals[[1]] = Sum[ (p0SAp.RAq[[j]]).(p0SBp.RBq[[j]]),{j,1,3}];

(*hnum # of exponentially increasing time steps, & exponentially decreasing integrand --> constant \[CapitalPhi]S error throughout*)

times=h*(Exp[Range[0,Log[tmax/h],Log[tmax/h]/hnum]])//N;
times2= Table[Total[Drop[times,-j]],{j,hnum,0,-1}];
       maxnum=Select[times2,#>5/k&,1][[1]];
maxpos=Flatten[Position[times2,maxnum]][[1]];
cutoff=-1+maxpos-hnum;
\[CapitalDelta]t=Drop[times,cutoff];
t=Drop[times2,cutoff];
\[Sigma]vals=Drop[\[Sigma]vals,1+cutoff];
hnum=Length[\[CapitalDelta]t];
If[abort==True,Abort[]];

(*eqs 4.33, 4.28*)
Table[
	Table[RAq[[iter]]=Quiet@MatrixExp[-LA*\[CapitalDelta]t[[j]],RAq[[iter]]]//Chop;(*set |S_q> = e^-Ldt|S_q> i.e. move by 1 time step*)
		RBq[[iter]]=Quiet@MatrixExp[-LB*\[CapitalDelta]t[[j]],RBq[[iter]]]//Chop(*MatrixExp[M,v] gives harmless error if v\[Equal]0 \[Rule] Quiet@ stops the error msg*)
		,{iter,1,3}
		];
	
	\[Sigma]vals[[j+1]]=Sum[(p0SAp.RAq[[iter]])
			       .(p0SBp.RBq[[iter]])
				,{iter,1,3}
				]
			 *Exp[-k*t[[j]]];
	If[Or[RAq==0,RBq==0],Break[]]
	,{j,1,hnum}
	];

\[Sigma]vals=Chop[\[Sigma]vals]*k*(1/M)//N;
 

(*Use Simpson's 1/3 rule*)
\[CapitalPhi]S=0;
\[CapitalPhi]S=   1/3 *(\[CapitalDelta]t[[1]]*\[Sigma]vals[[1]]
		+4*Sum[\[Sigma]vals[[j]]*\[CapitalDelta]t[[j]],{j,2,hnum ,2}] (*error integrating trailing end of graph if hnum+1 is even; the integrand \[Sigma](t)e^-kt is tiny there anyway *)
		+2*Sum[\[Sigma]vals[[j]]*\[CapitalDelta]t[[j]],{j,3,hnum ,2}]
		+\[CapitalDelta]t[[-1]]*\[Sigma]vals[[hnum+1]] 
			);

\[CapitalPhi]S= \[CapitalPhi]S+0.25

);




