(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
(*  Calculation[m, n,l, \[Omega]mT, HFImT, dc, k, Abort]

m must be even, dc=1/(6\[Tau]_c) where \[Tau]_c is time to rotate by 1 radian,
 Abort=True runs everything but the integral dt, for debugging (e.g. evaluating \[Sigma](t) at a given time);

HFImT is a list of tuples of the form {"X",a,\[CapitalDelta]A,\[Delta]A}: X=A or X=B, a = isotropic HFI strength/mT, \[CapitalDelta]A = axial HFI strength/mT, \[Delta]A = rhombic HFI strength/mT;

isotropic strength = (A_xx+A_yy+A_zz)/3, axial strength = (2A_zz-A_xx-A_yy), rhombic strength = (A_xx-A_yy) (<- not sure about the overall sign here);

If you want a spin-1 term, add "1" to the end of the tuple: {"A",1.2,0.7,0,1}. Anything other than 1 added at the end is ignored;
This of course is substantially more effort than computing a spin-1/2 term;

Example uses: Calculation[6,6,0,{{"A",1.2,0.7,0},{"A",1,0,0},{"B",1.7,1.2,0}},0,10^6,False];
			Calculation[12,12,1,{{"A",1,0.5,1},{"B",1,0,0,1}},1/(6*10^-6),False];

eq X.XX refers to J. Lau's part II thesis;*)


(* ::Input::Initialization:: *)
A[n_,l_,i_,j_,k_]:=n*l*(i-1)+l*(j-1)+k; (*Function to flatten a 3D tensor to a 1D one*)
DiffusionMatrix[m_,n_,l_,\[Chi]_,Potential_]:=(
mnl=m*n*l;  da=(2.0 \[Pi])/m; dy=(2.0 \[Pi])/l; dq=2.0/n;q[j_]:=-1.0+(j-0.5)dq; W=SparseArray[{},{mnl,mnl}];
(*************All the A[] functions below would need to be replaced with this new 5-argument one... (could be done using find+replace) *********************)
(*--------------------------------------------------------*)

(*middle cases*)
(*From Wagner-Rundell Thesis: Eqs. 6.20 - 6.22*)
Do[f=1/(da^2*(1-q[j]^2));
W[[A[n,l,i,j,k],A[n,i+1,j]]]=W[[A[n,i,j],A[n,i+1,j]]]+f; 
 W[[A[n,i,j],A[n,i,j]]]=W[[A[n,i,j],A[n,i,j]]]-2.0*f;
 W[[A[n,i,j],A[n,i-1,j]]]=W[[A[n,i,j],A[n,i-1,j]]]+f,
 {j,1,n},{k,1,l},{i,2,m-1}];
(*boundary case 1*)
(*From Wagner-Rundell Thesis: Eqs. 6.24 - 6.26*)

(*Manually implementing the periodicity of W, so linking position 1 with position M.*)
Do[f=1/(da^2*(1-q[j]^2));W[[A[n,m,j],A[n,1,j]]]=W[[A[n,m,j],A[n,1,j]]]+f;W[[A[n,m,j],A[n,m,j]]]=W[[A[n,m,j],A[n,m,j]]]-2.0*f;W[[A[n,m,j],A[n,m-1,j]]]=W[[A[n,m,j],A[n,m-1,j]]]+f,
 {j,1,n}];
(*boundary case 2*)
(*From Wagner-Rundell Thesis: Eqs. 6.27 - 6.29*)
Do[f=1/(da^2*(1-q[j]^2));W[[A[n,1,j],A[n,2,j]]]=W[[A[n,1,j],A[n,2,j]]]+f;W[[A[n,1,j],A[n,1,j]]]=W[[A[n,1,j],A[n,1,j]]]-2.0*f;W[[A[n,1,j],A[n,m,j]]]=W[[A[n,1,j],A[n,m,j]]]+f,
 {j,1,n}];
(*--------------------------------------------------------*)
(**************needs fixing properly **********************)
Do[f=1/(dy^2*(1-q[j]^2));
W[[A[n,l,i,j,k],A[n,i+1,j]]]=W[[A[n,i,j],A[n,i+1,j]]]+f;
 W[[A[n,i,j],A[n,i,j]]]=W[[A[n,i,j],A[n,i,j]]]-2.0*f;
 W[[A[n,i,j],A[n,i-1,j]]]=W[[A[n,i,j],A[n,i-1,j]]]+f,
 {j,1,n},{k,1,l},{i,2,m-1}];
Do[f=1/(dy^2*(1-q[j]^2));W[[A[n,m,j],A[n,1,j]]]=W[[A[n,m,j],A[n,1,j]]]+f;W[[A[n,m,j],A[n,m,j]]]=W[[A[n,m,j],A[n,m,j]]]-2.0*f;W[[A[n,m,j],A[n,m-1,j]]]=W[[A[n,m,j],A[n,m-1,j]]]+f,
 {j,1,n}];

Do[f=1/(dy^2*(1-q[j]^2));W[[A[n,1,j],A[n,2,j]]]=W[[A[n,1,j],A[n,2,j]]]+f;W[[A[n,1,j],A[n,1,j]]]=W[[A[n,1,j],A[n,1,j]]]-2.0*f;W[[A[n,1,j],A[n,m,j]]]=W[[A[n,1,j],A[n,m,j]]]+f,
 {j,1,n}];
(*--------------------------------------------------------*)
Do[f=(-2*q[j])/(da*dy*(1-q[j]^2));]
(*--------------------------------------------------------*)
Do[f=(1.0-q[j]^2)/dq^2;W[[A[n,i,j],A[n,i,j+1]]]=W[[A[n,i,j],A[n,i,j+1]]]+f;W[[A[n,i,j],A[n,i,j]]]=W[[A[n,i,j],A[n,i,j]]]-2.0*f;W[[A[n,i,j],A[n,i,j-1]]]=W[[A[n,i,j],A[n,i,j-1]]]+f,
 {j,2,n-1},{i,1,m}];

Do[f=(1.0-q[n]^2)/dq^2;If[i<=m/2,ip=i+m/2,ip=i-m/2];W[[A[n,i,n],A[n,ip,n]]]=W[[A[n,i,n],A[n,ip,n]]]+f;W[[A[n,i,n],A[n,i,n]]]=W[[A[n,i,n],A[n,i,n]]]-2.0*f;W[[A[n,i,n],A[n,i,n-1]]]=W[[A[n,i,n],A[n,i,n-1]]]+f,
{i,1,m}];

Do[f=(1.0-q[1]^2)/dq^2;If[i<=m/2,ip=i+m/2,ip=i-m/2];W[[A[n,i,1],A[n,i,2]]]=W[[A[n,i,1],A[n,i,2]]]+f;W[[A[n,i,1],A[n,i,1]]]=W[[A[n,i,1],A[n,i,1]]]-2.0*f;W[[A[n,i,1],A[n,ip,1]]]=W[[A[n,i,1],A[n,ip,1]]]+f,
{i,1,m}];
(*--------------------------------------------------------*)

Do[f=q[j]/dq;W[[A[n,i,j],A[n,i,j+1]]]=W[[A[n,i,j],A[n,i,j+1]]]-f;
W[[A[n,i,j],A[n,i,j-1]]]=W[[A[n,i,j],A[n,i,j-1]]]+f,
 {j,2,n-1},{i,1,m}];

Do[f=q[n]/dq;If[i<=m/2,ip=i+m/2,ip=i-m/2];W[[A[n,i,n],A[n,ip,n]]]=W[[A[n,i,n],A[n,ip,n]]]-f;W[[A[n,i,n],A[n,i,n-1]]]=W[[A[n,i,n],A[n,i,n-1]]]+f,
{i,1,m}];

Do[f=q[1]/dq;If[i<=m/2,ip=i+m/2,ip=i-m/2];W[[A[n,i,1],A[n,i,2]]]=W[[A[n,i,1],A[n,i,2]]]-f;W[[A[n,i,1],A[n,ip,1]]]=W[[A[n,i,1],A[n,ip,1]]]+f,
 {i,1,m}];


(* Do[f=4.0*\[Chi]/n^2;W[[A[n,i,j],A[n,i,j]]]=W[[A[n,i,j],A[n,i,j]]]+f, {j,2,n-1},{i,1,m}];

Do[f=\[Chi](3.0 n-8.0)/(2.0 n^2);W[[A[n,i,j],A[n,i,j]]]=W[[A[n,i,j],A[n,i,j]]]-f,{j,1,n,n-1},{i,1,m}]; *)

ColumnSum=Table[Total[W[[All,b]]],{b,1,mnl}];
Do[f=ColumnSum[[A[n,i,j]]];W[[A[n,i,j],A[n,i,j]]]=W[[A[n,i,j],A[n,i,j]]]-f, {j,1,n},{i,1,m}];
ColumnSum=Table[Total[W[[All,b]]],{b,1,mnl}] //Chop );



Id=({
 {1, 0},
 {0, 1}
});     Subscript[\[Sigma], x]=({
 {0, 1/2},
 {1/2, 0}
});     Subscript[\[Sigma], y]=({
 {0, -I/2},
 {I/2, 0}
});     Subscript[\[Sigma], z]=({
 {1/2, 0},
 {0, -1/2}
});
Id3=({
 {1, 0, 0},
 {0, 1, 0},
 {0, 0, 1}
});Subscript[\[CapitalSigma], x]=1/Sqrt[2]({
 {0, 1, 0},
 {1, 0, 1},
 {0, 1, 0}
});Subscript[\[CapitalSigma], y]=1/Sqrt[2]({
 {0, -I, 0},
 {I, 0, -I},
 {0, I, 0}
});Subscript[\[CapitalSigma], z]=({
 {1, 0, 0},
 {0, 0, 0},
 {0, 0, -1}
});
\[Sigma]p=Subscript[\[Sigma], x]+I Subscript[\[Sigma], y]; \[Sigma]m=Subscript[\[Sigma], x]-I Subscript[\[Sigma], y];
\[CapitalSigma]p=Subscript[\[CapitalSigma], x]+I Subscript[\[CapitalSigma], y];\[CapitalSigma]m=Subscript[\[CapitalSigma], x]-I Subscript[\[CapitalSigma], y];
Kron:=KroneckerProduct;
Kron2[{args__}]:=KroneckerProduct[args]; (*IMPORTANT: Kron2[] is same as KroneckerProduct[] but takes a single argument only: a list {M1,M2,M3,...} of matrices M*)
mT2angfreq=1.76 10^8;
Spins={Id/Sqrt[2.0],Sqrt[2.0] Subscript[\[Sigma], z],\[Sigma]p,\[Sigma]m};
IdNa=IdentityMatrix[2^Na*3^Na1];IdNb=IdentityMatrix[2^Nb*3^Nb1];
 SA[p_]:=Kron[Spins[[p]],IdNa]/Sqrt[2.0] //Flatten; SAdag[p_]:=Kron[Spins[[p]],IdNa]\[ConjugateTranspose]/Sqrt[2.0] //Flatten;  (*SAdag has Hermitian conjugate...*)
SB[p_]:=Kron[Spins[[p]],IdNb]/Sqrt[2.0] //Flatten; SBdag[p_]:=Kron[Spins[[p]],IdNb]\[ConjugateTranspose]/Sqrt[2.0] //Flatten; (*...before flattening*)
M=2^(Na+Nb)*3^(Na1+Nb1);(* # nuclear spin states; Na & Nb are assigned in Calculation[]*)


Hamiltonian[\[Omega]_,ihfca_,\[CapitalDelta]Aa_,\[Delta]Aa_,ihfcb_,\[CapitalDelta]Ab_,\[Delta]Ab_,m_,n_,l_,i_,j_,k_]:=(
dq=2.0/n; da=(2.0 \[Pi])/m; dy=(2.0 \[Pi])/l; q[jj_]:=-1.0+(jj-0.5)dq; \[Alpha][ii_]:=(ii-1.0)da; y[kk_]:=(kk-1.0)dy; 
WigD=Table[WignerD[{2,iter,0},a[i],ArcCos[q[j]],y[k]],{iter,2,-2,-1}];

IA=IdentityMatrix[2^(1+Na)*3^Na1]; (*Identity operator for entire radical A*)
IB=IdentityMatrix[2^(1+Nb)*3^Nb1];
IdNa=IdentityMatrix[2^Na*3^Na1];
IdNb=IdentityMatrix[2^Nb*3^Nb1];

NaId = If[Na>0,ConstantArray[Id,Na],{ {{1}} }];(*List of identity operators for N spin-0.5 nuclei*)
NbId = If[Nb>0,ConstantArray[Id,Nb],{ {{1}} }];
NaId1 = If[Na1>0,ConstantArray[Id3,Na1],{ {{1}} }];(*and for spin 1 nuclei*)
NbId1 = If[Nb1>0,ConstantArray[Id3,Nb1],{ {{1}} }];

(***Zeeman***)
HA=\[Omega](Kron[Subscript[\[Sigma], z],IdNa]); (*unconstrained radical so can set B-field to be at \[Theta]=0 w.l.g.*)
HB=\[Omega](Kron[Subscript[\[Sigma], z],IdNb]); 

(***Isotropic HFIs***)
NAId = If[Na>1,ConstantArray[Id,Na-1],{{1}}];(*Identity operators for N-1 nuclei*)
NBId = If[Nb>1,ConstantArray[Id,Nb-1],{{1}}];
NAId1 = If[Na1>1,ConstantArray[Id3,Na1-1],{{1}}];
NBId1 = If[Nb1>1,ConstantArray[Id3,Nb1-1],{{1}}];


(**************************************************************************************************************************)
(*The massive wall of code below ensures that we have terms corresponding to all hyperfine interactions. 

The Pax/Pay/Paz/Pam/Pap arrays simply contain the different lists of operators we need,
so Paz contains for e.g. Na=3 & Na1=2: {Subscript[\[Sigma], z] Id Id Id3 Id3}, {Id Subscript[\[Sigma], z] Id Id3 Id3}, {Id Id Subscript[\[Sigma], z] Id3 Id3}, {Id Id Id Subscript[\[CapitalSigma], x] Id3}, {Id Id Id Id3 Subscript[\[CapitalSigma], x]}. 
This is probably not implemented in the neatest way below given how simple the output is, but a single treatment for all the cases N=0,N=1 & N>1 seemed impossible. *)
(******************************)

Pax=Permutations[Append[NAId, Subscript[\[Sigma], x]]];Pay=Permutations[Append[NAId, Subscript[\[Sigma], y]]];Paz=Permutations[Append[NAId, Subscript[\[Sigma], z]]];
Pap=Permutations[Append[NAId, \[Sigma]p]]; Pam=Permutations[Append[NAId, \[Sigma]m]]; 
Pbx=Permutations[Append[NBId, Subscript[\[Sigma], x]]];Pby=Permutations[Append[NBId , Subscript[\[Sigma], y]]];Pbz=Permutations[Append[NBId , Subscript[\[Sigma], z]]];
Pbp=Permutations[Append[NBId, \[Sigma]p]]; Pbm=Permutations[Append[NBId, \[Sigma]m]]; 
If[Na==0,Pax=Pay=Paz=Pap=Pam={ {{1}} }];If[Nb==0,Pbx=Pby=Pbz=Pbp=Pbm={ {{1}} }];
If[Na==1,Pax={{Subscript[\[Sigma], x]}};Pay={{Subscript[\[Sigma], y]}};Paz={{Subscript[\[Sigma], z]}};Pap={{\[Sigma]p}};Pam={{\[Sigma]m}}];If[Nb==1,Pbx={{Subscript[\[Sigma], x]}};Pby={{Subscript[\[Sigma], y]}};Pbz={{Subscript[\[Sigma], z]}};Pbp={{\[Sigma]p}};Pbm={{\[Sigma]m}}]; 

Pax1=Permutations[Append[NAId1, Subscript[\[CapitalSigma], x]]];Pay1=Permutations[Append[NAId1, Subscript[\[CapitalSigma], y]]];Paz1=Permutations[Append[NAId1, Subscript[\[CapitalSigma], z]]]; (*spin-1 equivalent*)
Pap1=Permutations[Append[NAId1, \[CapitalSigma]p]]; Pam1=Permutations[Append[NAId1, \[CapitalSigma]m]]; 
Pbx1=Permutations[Append[NBId1, Subscript[\[CapitalSigma], x]]];Pby1=Permutations[Append[NBId1 , Subscript[\[CapitalSigma], y]]];Pbz1=Permutations[Append[NBId1 , Subscript[\[CapitalSigma], z]]];
Pbp1=Permutations[Append[NBId1, \[CapitalSigma]p]]; Pbm1=Permutations[Append[NBId1, \[CapitalSigma]m]]; 
If[Na1==0,Pax1=Pay1=Paz1=Pap1=Pam1={ {{1}} }];If[Nb1==0,Pbx1=Pby1=Pbz1=Pbp1=Pbm1={ {{1}} }];
If[Na1==1,Pax1={{Subscript[\[CapitalSigma], x]}};Pay1={{Subscript[\[CapitalSigma], y]}};Paz1={{Subscript[\[CapitalSigma], z]}};Pap1={{\[CapitalSigma]p}};Pam1={{\[CapitalSigma]m}}];If[Nb1==1,Pbx1={{Subscript[\[CapitalSigma], x]}};Pby1={{Subscript[\[CapitalSigma], y]}};Pbz1={{Subscript[\[CapitalSigma], z]}};Pbp1={{\[CapitalSigma]p}};Pbm1={{\[CapitalSigma]m}}];

P1ax=P1ay=P1az=P1ap=P1am=ConstantArray[0,Na];P2ax=P2ay=P2az=P2ap=P2am=ConstantArray[0,Na1];
P1bx=P1by=P1bz=P1bp=P1bm=ConstantArray[0,Nb];P2bx=P2by=P2bz=P2bp=P2bm=ConstantArray[0,Nb1];

(*for e.g. Na=2, Na1=2, construct {{Id,Id,Id3,Subscript[\[CapitalSigma], z]},{Id,Id,Subscript[\[CapitalSigma], z],Id3}} & {{Subscript[\[Sigma], z],Id,Id3,Id3},{Id,Subscript[\[Sigma], z],Id3,Id3}} and then glue them together for each x,y,z and A,B*)
Table[P1ax[[j]]=Join[Pax[[j]],NaId1],{j,1,Na}];
Table[P1ay[[j]]=Join[Pay[[j]],NaId1],{j,1,Na}]; 
Table[P1az[[j]]=Join[Paz[[j]],NaId1],{j,1,Na}]; 
Table[P1ap[[j]]=Join[Pap[[j]],NaId1],{j,1,Na}]; 
Table[P1am[[j]]=Join[Pam[[j]],NaId1],{j,1,Na}]; 
Table[P2ax[[j]]=Join[NaId,Pax1[[j]]],{j,1,Na1}];
Table[P2ay[[j]]=Join[NaId,Pay1[[j]]],{j,1,Na1}];
Table[P2az[[j]]=Join[NaId,Paz1[[j]]],{j,1,Na1}];
Table[P2ap[[j]]=Join[NaId,Pap1[[j]]],{j,1,Na1}];
Table[P2am[[j]]=Join[NaId,Pam1[[j]]],{j,1,Na1}];

Pax=Join[P1ax,P2ax];Pay=Join[P1ay,P2ay];Paz=Join[P1az,P2az];Pap=Join[P1ap,P2ap];Pam=Join[P1am,P2am];

Table[P1bx[[j]]=Join[Pbx[[j]],NbId1],{j,1,Nb}];
Table[P1by[[j]]=Join[Pby[[j]],NbId1],{j,1,Nb}];
Table[P1bz[[j]]=Join[Pbz[[j]],NbId1],{j,1,Nb}]; 
Table[P1bp[[j]]=Join[Pbp[[j]],NbId1],{j,1,Nb}];
Table[P1bm[[j]]=Join[Pbm[[j]],NbId1],{j,1,Nb}];
Table[P2bx[[j]]=Join[NbId,Pbx1[[j]]],{j,1,Nb1}];
Table[P2by[[j]]=Join[NbId,Pby1[[j]]],{j,1,Nb1}];
Table[P2bz[[j]]=Join[NbId,Pbz1[[j]]],{j,1,Nb1}]; 
Table[P2bp[[j]]=Join[NbId,Pbp1[[j]]],{j,1,Nb1}];
Table[P2bm[[j]]=Join[NbId,Pbm1[[j]]],{j,1,Nb1}]; 

Pbx=Join[P1bx,P2bx];Pby=Join[P1by,P2by];Pbz=Join[P1bz,P2bz];Pbp=Join[P1bp,P2bp];Pbm=Join[P1bm,P2bm];

(*Now that we (finally) have these arrays which enumerate the permuatations of all the operators, building the Hamiltonian is easy.*)

(**************************************************************************************************************************)
HA=HA+Sum[ihfca[[j]] (Kron2[Join[{Subscript[\[Sigma], x]},Pax[[j]]]] 
				+Kron2[Join[{Subscript[\[Sigma], y]},Pay[[j]]]]
				+Kron2[Join[{Subscript[\[Sigma], z]},Paz[[j]]]])

		,{j,1,Natot}] ;(*Natot=0 \[Rule] sum is j=1 to j=0 -> since 0<1 there are then no terms in the sum*)

HB=HB+Sum[ihfcb[[j]] (Kron2[Join[{Subscript[\[Sigma], x]},Pbx[[j]]]] 
				+Kron2[Join[{Subscript[\[Sigma], y]},Pby[[j]]]]
				+Kron2[Join[{Subscript[\[Sigma], z]},Pbz[[j]]]])

		,{j,1,Nbtot}] ;

(***Axial HFIs***)
Ta=ConstantArray[0,{Natot,5}];(*each row is the same as the T from original code/Lau 2009 paper, but for a given nucleus' HFI*)
Tb=ConstantArray[0,{Nbtot,5}];

(*The formulas for T below are identical to the original code but with Identity operators inserted for any extra nuclei.*)

Table[Ta[[j,1]]=1/2 Kron2[Join[{\[Sigma]m},Pam[[j]]]]; 
Ta[[j,2]]=  1/2 (Kron2[Join[{Subscript[\[Sigma], z]},Pam[[j]]]]+Kron2[Join[{\[Sigma]m},Paz[[j]]]]);
Ta[[j,3]]=Sqrt[2/3](Kron2[Join[{Subscript[\[Sigma], z]},Paz[[j]]]]-1/4 (Kron2[Join[{\[Sigma]p},Pam[[j]]]]+Kron2[Join[{\[Sigma]m},Pap[[j]]]])); 
Ta[[j,4]]=-(1/2)(Kron2[Join[{Subscript[\[Sigma], z]},Pap[[j]]]]+Kron2[Join[{\[Sigma]p},Paz[[j]]]]);

Ta[[j,5]]=1/2 Kron2[Join[{\[Sigma]p},Pap[[j]]]],
{j,1,Natot}]//Chop;

Table[Tb[[j,1]]=1/2 Kron2[Join[{\[Sigma]m},Pbm[[j]]]]; 
Tb[[j,2]]=  1/2 (Kron2[Join[{Subscript[\[Sigma], z]},Pbm[[j]]]]+Kron2[Join[{\[Sigma]m},Pbz[[j]]]]);
Tb[[j,3]]=Sqrt[2/3](Kron2[Join[{Subscript[\[Sigma], z]},Pbz[[j]]]]-1/4 (Kron2[Join[{\[Sigma]p},Pbm[[j]]]]+Kron2[Join[{\[Sigma]m},Pbp[[j]]]])); 
Tb[[j,4]]=-(1/2)(Kron2[Join[{Subscript[\[Sigma], z]},Pbp[[j]]]]+Kron2[Join[{\[Sigma]p},Pbz[[j]]]]);

Tb[[j,5]]=1/2 Kron2[Join[{\[Sigma]p},Pbp[[j]]]],
{j,1,Nbtot}]//Chop;


HA=HA+Sum[ 
		(\[CapitalDelta]Aa[[iter]]/Sqrt[6])Sum[
					WigD[[mm]] Ta[[iter,mm]],

					{mm,1,5}]//N//Simplify,
		{iter,1,Natot}]; 

HB=HB+Sum[ 
		(\[CapitalDelta]Ab[[iter]]/Sqrt[6])Sum[
					WigD[[mm]] Tb[[iter,mm]],

					{mm,1,5}]//N//Simplify,
		{iter,1,Nbtot}];
(***Rhombic HFIs***)

HA=HA+Sum[
		(\[Delta]Aa[[iter]]/2)Sum[
					Sum[
						WignerD[{2,mm,iter2}, \[Alpha][i],ArcCos[q[j]],y[k]]
						,{iter2,-2,2,4}
					   ]
				       *Ta[[iter,mm]],

					{mm,1,5}]//N//Simplify,
		{iter,1,Natot}];

HB=HB+Sum[
		(\[Delta]Ab[[iter]]/2)Sum[
					Sum[
						WignerD[{2,mm,iter2}, \[Alpha][i],ArcCos[q[j]],y[k]]
						,{iter2,-2,2,4}
					   ]
				       *Tb[[iter,mm]],

					{mm,1,5}]//N//Simplify,
		{iter,1,Nbtot}];

HAliouville=Kron[HA,IA]-Kron[IA,Transpose[HA]] ; 
HBliouville = Kron[HB,IB]-Kron[IB,Transpose[HB]] ; );

Clear[m,n,\[Omega],ahfc,\[CapitalDelta]A,\[Theta],\[Chi],dc,k,t]

Calculation[m_,n_,l_,\[Omega]mT_,HFImT_,dc_,K_,abort_]:=(
HFI=HFImT;
mnl=m*n*l; 
{\[Omega],HFI[[All,{2,3,4}]]}={\[Omega]mT,HFImT[[All,{2,3,4}]]}*mT2angfreq;

(*** Extract & organise constants from fct argument ***)
Ahfc =Pick[HFI[[All]],StringStartsQ[HFI[[All,1]],"A"]]; (*pick out A terms*)
Na =Natot=Length[Ahfc[[All,1]]]; (*see how many there are*)
Lengths=Table[Length[Ahfc[[j]]]>4,{j,1,Length[Ahfc]}]; (*tabulate which are longer than 4*)
Length4s=Position[Lengths,True]//Flatten;
Na1=Count[Ahfc[[Length4s]][[All,5]],1];(*see how many have "1" in the 4th entry*)
Na=Na-Na1;
Spin1sinLength4s=Position[Ahfc[[Length4s]][[All,5]],1]//Flatten; (*Find position **in Length4s** of spin 1s*)
fordeletion=Ahfc[[Length4s[[Spin1sinLength4s]]]]; (*and relate these to the actual indices in **Ahfc** *)
Ahfc=DeleteCases[Ahfc,Alternatives@@fordeletion]; (*delete these spin 1 terms*)
Ahfc=Join[Ahfc,fordeletion] ; (*and stick them all at the end (to match the order of operators in Hamiltonian[])*)
ihfca = Ahfc[[All,2]];
\[CapitalDelta]Aa= Ahfc[[All,3]];
\[Delta]Aa= Ahfc[[All,4]];

Bhfc =Pick[HFI[[All]],StringStartsQ[HFI[[All,1]],"B"]];
Nb =Nbtot=Length[Bhfc[[All,1]]];
Lengths=Table[Length[Bhfc[[j]]]>4,{j,1,Length[Bhfc]}];
Length4s=Position[Lengths,True]//Flatten;
Nb1=Count[Bhfc[[Length4s]][[All,5]],1];
Nb=Nb-Nb1;
Spin1sinLength4s=Position[Bhfc[[Length4s]][[All,5]],1]//Flatten;
fordeletion=Bhfc[[Length4s[[Spin1sinLength4s]]]];
Bhfc=DeleteCases[Bhfc,Alternatives@@fordeletion];
Bhfc=Join[Bhfc,fordeletion] ;
ihfcb = Bhfc[[All,2]];
\[CapitalDelta]Ab= Bhfc[[All,3]];
\[Delta]Ab= Bhfc[[All,4]];

If[Na==Na1==0,ihfca={0};\[CapitalDelta]Aa={0}];If[Nb==Nb1==0,ihfcb={0};\[CapitalDelta]Ab={0}]; (*for N=0 sets our constants to {0} instead of having them as empty arrays {}*)

DiffusionMatrix[m,n,0,1]; (*no potential \[Rule] \[Chi]=0*)

Hamiltonian[\[Omega],ihfca,\[CapitalDelta]Aa,ihfcb,\[CapitalDelta]Ab,m,n,l,i,j,k];

p0=ConstantArray[1/mnl,mnl]; (*Initial distribution of orientations is simply uniform*)

(********************************)
p0=p0*Sqrt[mnl]; (*BRUH MOMENT to make singlet probability 1 at t=0*)
(********************************)

p0SA=Table[Kron[p0,SA[j]]//Flatten,{j,1,4}];p0SAdag=Table[Kron[p0,SAdag[j]]//Flatten,{j,1,4}];
p0SB=Table[Kron[p0,SB[j]]//Flatten,{j,1,4}];p0SBdag=Table[Kron[p0,SBdag[j]]//Flatten,{j,1,4}];

IdHA=SparseArray[{a_,a_}->1,Dimensions[HAliouville]];IdHB=SparseArray[{a_,a_}->1,Dimensions[HBliouville]];

ijkvals=Tuples[{Range[m],Range[n],Range[l]}]; (*spits out all possible {m,n,l} for use below*)

 (*eq 4.8*)
HHA=Sum[
		Kron[
			SparseArray[{a,a}->1,{mnl,mnl}],
			HAliouville/.Thread[{i,j,k}->ijkvals[[a]] ] (*Thread[] lets you sub in an array / a pair of elements instead of individually doing 'em*)
			 ],
		{a,1,mnl}
		]; 

HHB=Sum[
		Kron[
			SparseArray[{a,a}->1,{mnl,mnl}],
			HBliouville/.Thread[{i,j,k}->ijkvals[[a]] ] 
			],
		{a,1,mnl}
		];

(*eqs 4.34, 4.05 *)
LA:= I HHA-dc Kron[W,IdHA]; 
LB:= I HHB-dc Kron[W,IdHB];

dt =10^(-9);
h =dt/2 ;
tmax = 5/K;(*t>5/k negligible*)
hnum=999*10^6/K;(* hnum+1 is total number of points, due to the point at t=0*)

\[Sigma]vals=ConstantArray[0,hnum+1];
RAq=Table[p0SA[[q]],{q,2,4}] ;(*initialise at t=0*)
RBq=Table[p0SBdag[[q]],{q,2,4}];
p0SAp=Table[p0SAdag[[p]],{p,2,4}]; (*And collect LH p-indexed terms in a vector*)
p0SBp=Table[p0SB[[p]],{p,2,4}];

\[Sigma]vals[[1]] = Sum[ (p0SAp.RAq[[j]]).(p0SBp.RBq[[j]]),{j,1,3}];

(*hnum # of exponentially increasing time steps, & exponentially decreasing integrand --> constant \[CapitalPhi]S error throughout*)

times=h*(Exp[Range[0,Log[tmax/h],Log[tmax/h]/hnum]])//N;
times2= Table[Total[Drop[times,-j]],{j,hnum,0,-1}];
       maxnum=Select[times2,#>5/K&,1][[1]];
maxpos=Flatten[Position[times2,maxnum]][[1]];
cutoff=-1+maxpos-hnum;
\[CapitalDelta]t=Drop[times,cutoff];
t=Drop[times2,cutoff];
\[Sigma]vals=Drop[\[Sigma]vals,1+cutoff];
hnum=Length[\[CapitalDelta]t];
If[abort==True,Abort[]];

Table[
	Table[RAq[[iter]]=Quiet@MatrixExp[-LA*\[CapitalDelta]t[[j]],RAq[[iter]]]//Chop;
		RBq[[iter]]=Quiet@MatrixExp[-LB*\[CapitalDelta]t[[j]],RBq[[iter]]]//Chop
		,{iter,1,3}
		];
	
	\[Sigma]vals[[j+1]]=Sum[(p0SAp.RAq[[iter]])
			       .(p0SBp.RBq[[iter]])
				,{iter,1,3}
				]
			 *Exp[-K*t[[j]]];
	If[Or[RAq==0,RBq==0],Break[]]
	,{j,1,hnum}
	];

\[Sigma]vals=Chop[\[Sigma]vals]*K*(1/M)//N;
 

(*Use Simpson's 1/3 rule*)
\[CapitalPhi]S=0;
\[CapitalPhi]S=   1/3 *(\[CapitalDelta]t[[1]]*\[Sigma]vals[[1]]
		+4*Sum[\[Sigma]vals[[j]]*\[CapitalDelta]t[[j]],{j,2,hnum ,2}] (*error integrating trailing end of graph if hnum+1 is even; the integrand \[Sigma](t)e^-kt is tiny there anyway *)
		+2*Sum[\[Sigma]vals[[j]]*\[CapitalDelta]t[[j]],{j,3,hnum ,2}]
		+\[CapitalDelta]t[[-1]]*\[Sigma]vals[[hnum+1]] 
			);

\[CapitalPhi]S= \[CapitalPhi]S+0.25

);



